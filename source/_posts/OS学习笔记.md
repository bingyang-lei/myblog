---
title: OS笔记
date: 2025-03-01 23:47:14
---
南京大学蒋炎岩老师《操作系统》课程笔记
## 绪论

**一个重塑全人类的 prompt：**

> 我在做 [X]。如果你是一位专业人士，有更好的方法和建议吗？尽可能全面。

操作系统：管理软/硬件资源、为程序提供服务

> A body of software, in fact, that is responsible for *making it easy to run programs* (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)

### 应用视角的操作系统

程序是个状态机，但有些东西单靠程序本身无法实现。

“纯粹的计算” 只能改变**程序内的状态**，但有些 API 涉及到 “程序外的状态”，这就和操作系统有关了

>操作系统最大的职责就是让我们**在编程时感受不到操作系统的存在**——我们在编程时想象程序 “独占整个计算机，逐条指令执行”，大部分时候都不用 “考虑” 操作系统的存在。当系统调用发生时，程序执行被完全暂停，但操作系统依然在工作——就像麻醉后醒来，周围的环境发生了变化，但我们完全没有感到时间的流逝。by jyy

**任何程序 = minimal.S = 状态机**

- 总是从被操作系统加载开始
  - 通过另一个进程执行 execve 设置为初始状态
- 经历状态机执行 (计算 + syscalls)
  - 进程管理：fork, execve, exit, ...
  - 文件/设备管理：open, close, read, write, ...
  - 存储管理：mmap, brk, ...
- 最终调用 _exit (exit_group) 退出



### 硬件视角的操作系统

硬件**根本不知道有没有操作系统**：

- 我就是个无情执行指令的状态机
  - 见什么指令执行什么指令

- 下层不需要知道上面怎么用，只管 “无情地提供服务”
  - 系统调用支撑应用程序
  - 指令集支撑高级语言程序

**操作系统就是一个普通的 (二进制) 程序**：

- 接管了中断、I/O、……
  - 应用程序不能直接访问
- 把应用程序 “放” 到 CPU 上运行一会
  - 中断后，操作系统又开始执行
  - (操作系统启动后，操作系统就变成了一个中断处理程序)

---

刚刚遗漏的一个细节：

CPU = 无情执行指令的机器

- 从 CPU Reset 开始执行
  - 从 Mem[PC] 取指令
  - 译码、执行，如此往复

那么，Reset处的代码是什么呢？

答案：系统厂商的代码

- 把一个特殊的存储器 memory-map 到 CPU Reset 后的代码
  - 这段代码 “出生” 就有机器完整的控制权

---

从固件到操作系统：

- 40年前的约定是，固件(BIOS)判断磁盘的前512字节（MBR, master boot record, 主引导扇区）是否可加载，然后将其内容加载到内存的0x7c00，因此如果你写一个简单的汇编程序在这里，固件就会先加载MBR，然后你的汇编程序再加载大的操作系统进来
- 我们可以“调试”这个过程，从而看到固件加载MBR的过程

`python`中，使用`os.system`执行命令和在命令行执行命令一样，也会有相同的命令行中的输出，如果需要输入中途确认信息，程序会暂停

### 数学视角的操作系统：

- 程序是个状态机，硬件也是个状态机，操作系统就是个状态机管理器。
- 朴素的想，可以通过状态机建模和遍历，实现对软件正确性的证明。



